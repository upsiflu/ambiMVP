module Compositron exposing
    ( State, trivial, possible_transformations, preview )

import Tree exposing ( Tree )
import Tree.Zipper exposing  ( .. )
import Tuple exposing ( first, second )

import Html exposing ( .. )
import Html.Attributes exposing  ( .. )
import Html.Events exposing ( .. )

---- Compositron ----

type alias State = Compositron

type alias Node = { signature : Signature, item : Item }

    
type alias Compositron = Zipper Node
type alias Compositree = Tree Node

type alias Signature = String
      
type Item
    = Style
    | Value ( Maybe String )
    | Parag
    | Targeted Item -- only use to produce Html!

type alias Endofunction =
    Compositron -> Compositron



                   
---- create ----

trivial : Compositron
trivial = Tree.tree { signature = "0", item = Value ( Just "Hey Kai!" ) }
              [ Tree.singleton { signature = "00", item = Value ( Just "Some value!" ) }
              , Tree.tree { signature = "01", item = Style }
                  [ Tree.singleton { signature = "010", item = Value ( Just "align left" ) }
                  , Tree.tree { signature = "011", item = Style } []
                  ]
              ]
          |> fromTree



---- read ----

signature = Tree.Zipper.label >> .signature
item = Tree.Zipper.label >> .item

---- map ----

target : Signature -> Compositron -> Compositron
target sig =
    findFromRoot ( \node -> .signature node == sig )
    >> Maybe.withDefault trivial



---- preview ----

preview : Compositron ->
          ( { serial : String, function : Endofunction, inverse : Endofunction } -> msg ) ->
          Html msg
preview compositron dispatch
    = let
        targeted = Tree.Zipper.label compositron
      in compositron |> mapLabel ( \node -> { node | item = Targeted targeted.item } ) >>
      root >>
      toHtml targeted dispatch

      
toHtml : Node ->
         ( { serial : String, function : Endofunction, inverse : Endofunction } -> msg ) ->
         Compositron ->
         Html msg
toHtml targeted dispatch compositron =
    let
        inner = children compositron |> List.map ( fromTree >> toHtml targeted dispatch )
        navigator = signature compositron |> Target |> copy compositron |> dispatch |> onClick
    in case ( item compositron ) of
        Style -> div [ class "style", navigator ]
                 [ text ( signature compositron )
                 , text ": style"
                 , div [] inner ]
        Value string -> div [ class "value", navigator ]
                 [ text ( signature compositron )
                 , text ": value: "
                 , text ( string |> Maybe.withDefault "-" )
                 , div [] inner ]
        Parag -> p [ class "paragraph", navigator ]
                 [ text ( signature compositron )
                 , text ": paragraph"
                 , div [] inner ]
        Targeted i -> case i of
            Style ->
                  div [ class "style targeted", navigator ]
                      [ text ( signature compositron )
                      , text ": style"
                      , div [] inner ]
                
            Value string ->
                  div [ class "value targeted", navigator ]
                      [ text ( signature compositron )
                      , text ": value: "
                      , text ( string |> Maybe.withDefault "-" )
                      , div [] inner ]
                
            Parag ->
                  p   [ class "paragraph targeted" ]
                      [ text ( signature compositron )
                      , text ": paragraph"
                      , div [] inner ]
                
            _ -> text ";"
                                                        



                 
---- edits ----

allEdits c = [ Target "0", Target "1" ]

type Edit
    = Target String

    
possible_transformations previous =
    List.map
        ( \edit -> copy previous edit )
        ( allEdits previous )
            

copy : Compositron -> Edit -> { serial : String, function : Endofunction, inverse : Endofunction }
copy previous edit =
    case edit of
        Target sig ->
            { serial = "Target "++sig++" "++( signature previous )
            , function = target sig
            , inverse = target ( signature previous )
            }

